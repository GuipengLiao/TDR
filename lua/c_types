loadfile(lua_dir .. "lib/hotdata/syntactic_node.lua")();
loadfile(lua_dir .. "lib/common.lua")();

function print_val(val)
	if val.type == E_SNVT_IDENTIFIER then
		io.write(val.val.identifier)
	elseif val.type == E_SNVT_CHAR then
		io.write("'")
		if(val.val.c == '\n')then
			io.write('\\n')
		else
			io.write(val.val.c)
		end
		io.write("'")
	elseif val.type == E_SNVT_DOUBLE then
		io.write(val.val.d)
	elseif val.type == E_SNVT_BOOL then
		io.write(val.val.b)
	elseif val.type == E_SNVT_STRING then
		--需要处理字符串中的转义
		io.write('"')
		io.write(val.val.str)
		io.write('"')
	elseif val.type == E_SNVT_INT64 then
		io.write(val.val.i64)
	elseif val.type == E_SNVT_UINT64 then
		io.write(val.val.ui64)
	elseif val.type == E_SNVT_HEX_INT64 then
		io.write(val.val.hex_i64)
	elseif val.type == E_SNVT_HEX_UINT64 then
		io.write(val.val.hex_ui64)
	end
end

function on_const(const)
	io.write('#define\t')
	io.write(const.identifier)
	io.write(' ')
	print_val(const.val)
	io.write('\n')
end

function print_type(type, args)
	if(type.type == E_SNT_SIMPLE)then
		if(type.st == E_ST_CHAR)then
			io.write('hpchar')
		elseif(type.st == E_ST_DOUBLE)then
			io.write('hpdouble')
		elseif(type.st == E_ST_BOOL)then
			io.write('hpbool')
		elseif(type.st == E_ST_INT8)then
			io.write('hpint8')
		elseif(type.st == E_ST_INT16)then
			io.write('hpint16')
		elseif(type.st == E_ST_INT32)then
			io.write('hpint32')
		elseif(type.st == E_ST_INT64)then
			io.write('hpint64')
		elseif(type.st == E_ST_UINT8)then
			io.write('hpuint8')
		elseif(type.st == E_ST_UINT16)then
			io.write('hpuint16')
		elseif(type.st == E_ST_UINT32)then
			io.write('hpuint32')
		elseif(type.st == E_ST_UINT64)then
			io.write('hpuint64')
		end
	elseif(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			io.write(args.arg_list[1].ot)
		elseif(type.ct == E_CT_STRING)then
			io.write('hpchar')
		end
	elseif(type.type == E_SNT_REFER)then
		io.write(type.ot);
	end
end

function on_typedef(typedef)
	io.write('typedef')
	io.write(' ')
	print_type(typedef.type, nil)
	io.write(' ')
	io.write(typedef.name)
	io.write(';\n')
end

function on_enum(enum)
	io.write('typedef enum _' .. enum.name)
	io.write('\n')
	io.write('{\n')
	for key, value in pairs(enum.enum_def_list) do
		io.write('\t' .. value.identifier .. ' = ')
		print_val(value.val)
		io.write(',\n')
	end
	io.write('}' .. enum.name .. ';\n')
	counter = enum.name .. '_NUM'
	for key, value in pairs(enum.type_annotations.ta_list) do
		if(value.type == E_TA_COUNTER)then
			counter = value.val.val.str
		end
	end
	print_line(0, '#define ' .. counter .. ' ' .. #enum.enum_def_list);
end

function on_object(type_name, object)
	io.write('typedef ' .. type_name .. ' _' .. object.name)
	io.write('\n')
	io.write('{\n')
	for key, value in pairs(object.field_list.field_list) do
		if(value.type.type == E_SNT_CONTAINER)then
			if(value.type.ct == E_CT_VECTOR)then
				io.write('\thpuint32 ')
				io.write(value.args.arg_list[3].ot)
				io.write(';\n')
			end
		end

		io.write('\t')
		print_type(value.type, value.args)
		io.write(' ')
		io.write(value.identifier)
		if(value.type.type == E_SNT_CONTAINER)then
			if(value.type.ct == E_CT_VECTOR)then
				io.write('[')
				io.write(value.args.arg_list[2].ot)
				io.write(']')
			elseif(value.type.ct == E_CT_STRING)then
				io.write('[')
				io.write(value.args.arg_list[1].ot)
				io.write(']')
			end
		end
		io.write(';\n')
	end
	io.write('}' .. object.name .. ';\n')
end

function main(hd)
	print_file_prefix()

	file_tag = hd.file_name
	file_tag = '_H_' .. string.gsub(hd.file_name, '[^a-zA-Z0-9]', '_') .. '_TYPES'
	io.write('#ifndef ' .. file_tag .. '\n')
	io.write('#define ' .. file_tag .. '\n')


	io.write('#include "hotpot/hp_platform.h"\n')
	if(ifiles ~= nil) then
		for k, v in pairs(ifiles) do
			print_line(0, '#include "' .. v .. '"')
		end
	end

	for key, value in pairs(hd['definition_list']) do
		if(value.type == E_DT_CONST)then
			on_const(value.definition.de_const)
		elseif(value.type == E_DT_TYPEDEF)then
			on_typedef(value.definition.de_typedef)
		elseif(value.type == E_DT_ENUM)then
			on_enum(value.definition.de_enum)
		elseif(value.type == E_DT_STRUCT)then
			on_object('struct', value.definition.de_struct)
		elseif(value.type == E_DT_UNION)then
			on_object('union', value.definition.de_union)
		end
	end
	io.write('#endif//' .. file_tag .. '\n')
end

main(hd)
