loadfile(lua_dir .. "lib/syntactic_node.lua")();


function get_symbol_access_by_type(identifier, type)
	prefix = ''
	suffix = ''
	if(type.type == E_SNT_SIMPLE)then
		prefix = 'data->'
	elseif(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			if(v.args.arg_list[0].type == E_SNT_SIMPLE)then
				prefix = 'data->'
			else
				prefix = '&data->'
			end
			suffix = '[i]'
		elseif(type.ct == E_CT_STRING)then
			prefix = 'data->'
		end
	elseif(type.type == E_SNT_REFER)then
		prefix = '&data->'
	end
	return prefix .. identifier .. suffix
end

function get_symbol_access(identifier, object)
	for k,v in pairs(object.field_list.field_list)do
			if(v.identifier == identifier)then
				return get_symbol_access_by_type(identifier, v.type)
			end
	end
	for k,v in pairs(object.parameters.par_list) do
		if(v.identifier == identifier)then
			return get_symbol_access_by_type(identifier, v.type)
		end
	end

	return identifier
end

function print_line(n, str)
	for i = 1, n do
		io.write('    ')
	end
	print(str)
end

function get_val(val, object)
	if val.type == E_SNVT_IDENTIFIER then
		return get_symbol_access(val.val.identifier, object)
	elseif val.type == E_SNVT_CHAR then
		return val.val.c
	elseif val.type == E_SNVT_DOUBLE then
		return val.val.d
	elseif val.type == E_SNVT_BOOL then
		return val.val.b
	elseif val.type == E_SNVT_STRING then
		return val.val.str
	elseif val.type == E_SNVT_INT64 then
		return val.val.i64
	elseif val.type == E_SNVT_UINT64 then
		return val.val.ui64
	elseif val.type == E_SNVT_HEX_INT64 then
		return val.val.hex_i64
	elseif val.type == E_SNVT_HEX_UINT64 then
		return val.val.hex_ui64
	end
end

function get_type(type, args)
	if(type.type == E_SNT_SIMPLE)then
		if(type.st == E_ST_CHAR)then
			return 'char'
		elseif(type.st == E_ST_DOUBLE)then
			return 'double'
		elseif(type.st == E_ST_BOOL)then
			return 'bool'
		elseif(type.st == E_ST_INT8)then
			return 'int8'
		elseif(type.st == E_ST_INT16)then
			return 'int16'
		elseif(type.st == E_ST_INT32)then
			return 'int32'
		elseif(type.st == E_ST_INT64)then
			return 'int64'
		elseif(type.st == E_ST_UINT8)then
			return 'uint8'
		elseif(type.st == E_ST_UINT16)then
			return 'uint16'
		elseif(type.st == E_ST_UINT32)then
			return 'uint32'
		elseif(type.st == E_ST_UINT64)then
			return 'uint64'
		end
	elseif(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			return args.arg_list[1].ot
		elseif(type.ct == E_CT_STRING)then
			return 'char'
		end
	elseif(type.type == E_SNT_REFER)then
		return type.ot;
	end
end

function on_enum_name(enum)
	print_line(0, 'void write_' .. enum.name .. '_name(HPAbstractWriter *self, ' .. enum.name .. ' *data)')
	print_line(0, '{')
	print_line(1, 'switch(*data)')
	print_line(1, '{')
	for key, value in pairs(enum.enum_def_list) do
		print_line(2, 'case ' .. value.identifier .. ':')
		print_line(3, 'write_enum_name(self, "' ..  value.identifier .. '");')
		print_line(3, 'break;')
	end
	print_line(1, '}')
	print_line(0, '}')
end

function on_enum_number(enum)
	print_line(0, 'void write_' .. enum.name .. '_number(HPAbstractWriter *self, const ' .. enum.name .. ' *data)')
	print_line(0, '{')
	print_line(1, 'write_enum_number(self, data);')
	print_line(0, '}')
end

function on_enum(enum)
	on_enum_name(enum)
	on_enum_number(enum)

	print_line(0, 'void write_' .. enum.name .. '(HPAbstractWriter *self, const ' .. enum.name .. ' *data)')
	print_line(0, '{')
	print_line(1, 'write_' .. enum.name .. '_name(self, data);')
	print_line(1, 'write_' .. enum.name .. '_number(self, data);')
	print_line(0, '}')
end


function on_struct(object)
	t = 0;
	line = 'void write_' .. object.name .. '(HPAbstractWriter *self, const ' .. object.name .. ' *data'
	for key, value in pairs(object.parameters.par_list) do
		line = line .. ' , '
		line = line .. get_type(value.type, nil)
		line = line .. ' *' .. value.identifier
	end
	line = line .. ')'
	print_line(t, line)
	print_line(t, '{')
	t = t + 1
	print_line(t, 'write_struct_begin(self, "' .. object.name .. '");')
	for key, value in pairs(object.field_list.field_list) do
		if(value.condition.empty == false)then			
			if(value.condition.exp.oper == E_EO_AND)then
				oper = '&'
			elseif(value.condition.exp.oper == E_EO_EQUAL)then
				oper = '=='
			end
			if(value.condition.exp.neg)then
				print_line(t, 'if (!(' .. get_val(value.condition.exp.op0, object) .. ' ' .. oper .. ' '.. get_val(value.condition.exp.op1, object) .. '))')
			else
				print_line(t, 'if (' .. get_val(value.condition.exp.op0, object) .. ' ' .. oper .. ' ' .. get_val(value.condition.exp.op1, object) .. ')')
			end
			print_line(t, '{')
			t = t + 1
		end

		if(value.type.type == E_SNT_CONTAINER)then
			if(value.type.ct == E_CT_VECTOR)then
				print_line(t, 'write_counter(self, "' .. value.args.arg_list[3].ot .. '", &data->' .. value.args.arg_list[3].ot .. ');');
				print_line(t, 'write_field_begin(self, "' .. value.identifier .. '");')
				print_line(t, '{')
				t = t + 1
				print_line(t, 'hpuint32 i;')
				print_line(t, 'for(i = 0; i < data->' .. value.args.arg_list[3].ot .. '; ++i)')
				print_line(t, '{')
				t = t + 1
				line = 'write_'
				line = line .. get_type(value.type, value.args)
				line = line .. '(self, &data->' .. value.identifier .. '[i]'
				for i=4, #value.args.arg_list do
					line = line .. ', &data->' .. value.args.arg_list[i].ot
				end
				line = line .. ');'
				print_line(t, line)
				t = t - 1
				print_line(t, '}')
				t = t - 1
				print_line(t, '}')
				print_line(t, 'write_field_end(self, "' .. value.identifier .. '");')
			elseif(value.type.ct == E_CT_STRING)then
				print_line(t, 'write_field_begin(self, "' .. value.identifier .. '");')
				print_line(t, 'write_string(self, data->' .. value.identifier .. ');')
				print_line(t, 'write_field_end(self, "' .. value.identifier .. '");')
			end
		else
			print_line(t, 'write_field_begin(self, "' .. value.identifier .. '");')
			line = 'write_' .. get_type(value.type, value.args) .. '(self, ' .. get_symbol_access(value.identifier, object)
				for ak, av in pairs(value.args.arg_list) do
					line = line .. ', ' .. get_symbol_access(av.ot, object)
				end
			line = line .. ');'
			print_line(t, line)
			print_line(t, 'write_field_end(self, "' .. value.identifier .. '");')
		end

		if(value.condition.empty == false)then
			t = t - 1
			print_line(t, '}')
		end
	end
	print_line(t, 'write_struct_end(self, "' .. object.name .. '");')
	t = t - 1
	print_line(t, '}')
end


function on_union(object)
	t = 0;
	line = 'void write_' .. object.name .. '(HPAbstractWriter *self, const ' .. object.name .. ' *data'
	for key, value in pairs(object.parameters.par_list) do
		line = line .. ' , '
		line = line .. get_type(value.type, nil)
		line = line .. ' *' .. value.identifier
	end
	line = line .. ')'
	print_line(t, line)
	print_line(t, '{')
	t = t + 1
	print_line(t, 'write_struct_begin(self, "' .. object.name .. '");')

	sw = 's'
	for key, value in pairs(object.ta.ta_list) do
		if(value.type == E_TA_SWITCH)then
			sw = value.val.val.identifier
		end
	end

	print_line(t, 'switch(*' .. sw .. ')')
	print_line(t, '{')
	t = t + 1
	for key, value in pairs(object.field_list.field_list) do
		print_line(t, 'case ' .. get_val(value.condition.exp.op1, object) .. ':')
		print_line(t, '{')
		t = t + 1
		print_line(t, 'write_field_begin(self, "' .. value.identifier .. '");')
		if(value.type.type == E_SNT_CONTAINER)then
			if(value.type.ct == E_CT_VECTOR)then
				print_line(t, 'hpuint32 i;')
				print_line(t, 'for(i = 0; i < data->' .. value.args.arg_list[3].ot .. '; ++i)')
				print_line(t, '{')
				t = t + 1
				line = 'write_' .. get_type(value.type, value.args) .. '(self, ' .. get_symbol_access(value.identifier, object)
				for ak, av in pairs(value.args.arg_list) do
					line = line .. ', ' .. get_symbol_access(av.ot, object)
				end
				line = line .. ');'
				print_line(t, line)
				t = t - 1
				print_line(t, '}')
			elseif(value.type.ct == E_CT_STRING)then
				print_line(t, 'write_string(self, data->' .. value.identifier .. ');')
			end
		else
			line = 'write_'
			line = line .. get_type(value.type, nil)
			line = line .. '(self, ' .. get_symbol_access(value.identifier, object)
			for ak, av in pairs(value.args.arg_list) do
				line = line .. ', &data->' .. av.ot
			end

			line = line .. ');'
			print_line(t, line)
		end
		print_line(t, 'write_field_end(self, "' .. value.identifier .. '");')
		print_line(t, 'break;')
		t = t - 1
		print_line(t, '}')
	end
	t = t - 1
	print_line(t, '}')
	print_line(t, 'write_struct_end(self, "' .. object.name .. '");')
	t = t - 1
	print_line(t, '}')
end

function main(hd)
	file_tag = hd.file_name
	file_tag = '_H_' .. string.gsub(hd.file_name, '[^a-zA-Z0-9]', '_') .. '_WRITER'
	io.write('#ifndef ' .. file_tag .. '\n')
	io.write('#define ' .. file_tag .. '\n')
	print_line(0, '#include "hotpot/hp_platform.h"')
	print_line(0, '#include "hotprotocol/hp_abstract_writer.h"')

	if(c_types_file)then
		io.write('#include \"' .. c_types_file .. '\"\n')
	end
	if(c_writer_header_file)then
		io.write('#include \"' .. c_writer_header_file .. '\"\n')
	end
	for key, value in pairs(hd['definition_list']) do
		if(value.type == E_DT_ENUM)then
			on_enum(value.definition.de_enum)
		elseif(value.type == E_DT_STRUCT)then
			on_struct(value.definition.de_struct)
		elseif(value.type == E_DT_UNION)then
			on_union(value.definition.de_union)
		end
	end
	io.write('#endif//' .. file_tag .. '\n')
end

main(hd)

