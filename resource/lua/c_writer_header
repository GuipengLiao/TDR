loadfile(lua_dir .. "lib/syntactic_node.lua")();

enum_list = {}

function get_symbol_access_by_type_suffix(identifier, type)
	if(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			return '[i]'
		end
	end
	return ''
end

function get_symbol_access_by_type_prefix(identifier, type)
	if(type.type == E_SNT_SIMPLE)then
		return ''
	elseif(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			if(v.args.arg_list[0].type == E_SNT_SIMPLE)then
				return ''
			else
				return '&'
			end
		elseif(type.ct == E_CT_STRING)then
			return ''
		end
	elseif(type.type == E_SNT_REFER)then
		if(enum_list[type.ot] == nil)then
			return '&'
		else
			return ''
		end
	end
	return ''
end

function get_symbol_access_by_type_prefix_reverse(identifier, type)
	if(type.type == E_SNT_SIMPLE)then
		return ''
	elseif(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			if(v.args.arg_list[0].type == E_SNT_SIMPLE)then
				return ''
			else
				return '*'
			end
		elseif(type.ct == E_CT_STRING)then
			return ''
		end
	elseif(type.type == E_SNT_REFER)then
		if(enum_list[type.ot] == nil)then
			return '*'
		else
			return ''
		end
	end
	return ''
end

function get_symbol_access(identifier, object)
	for k,v in pairs(object.parameters.par_list) do
		if(v.identifier == identifier)then
			prefix = get_symbol_access_by_type_prefix(identifier, v.type)
			suffix = get_symbol_access_by_type_suffix(identifier, v.type)
			return prefix .. identifier .. suffix
		end
	end

	for k,v in pairs(object.field_list.field_list)do
		if(v.identifier == identifier)then
			prefix = get_symbol_access_by_type_prefix(identifier, v.type)
			suffix = get_symbol_access_by_type_suffix(identifier, v.type)
			return prefix .. 'data->' .. identifier .. suffix
		end
	end

	return identifier
end

function print_line(n, str)
	for i = 1, n do
		io.write('    ')
	end
	print(str)
end

function get_val(val, object)
	if val.type == E_SNVT_IDENTIFIER then
		return get_symbol_access(val.val.identifier, object)
	elseif val.type == E_SNVT_CHAR then
		return val.val.c
	elseif val.type == E_SNVT_DOUBLE then
		return val.val.d
	elseif val.type == E_SNVT_BOOL then
		return val.val.b
	elseif val.type == E_SNVT_STRING then
		return val.val.str
	elseif val.type == E_SNVT_INT64 then
		return val.val.i64
	elseif val.type == E_SNVT_UINT64 then
		return val.val.ui64
	elseif val.type == E_SNVT_HEX_INT64 then
		return val.val.hex_i64
	elseif val.type == E_SNVT_HEX_UINT64 then
		return val.val.hex_ui64
	end
end

function get_type(type, args)
	if(type.type == E_SNT_SIMPLE)then
		if(type.st == E_ST_CHAR)then
			return 'char'
		elseif(type.st == E_ST_DOUBLE)then
			return 'double'
		elseif(type.st == E_ST_BOOL)then
			return 'bool'
		elseif(type.st == E_ST_INT8)then
			return 'int8'
		elseif(type.st == E_ST_INT16)then
			return 'int16'
		elseif(type.st == E_ST_INT32)then
			return 'int32'
		elseif(type.st == E_ST_INT64)then
			return 'int64'
		elseif(type.st == E_ST_UINT8)then
			return 'uint8'
		elseif(type.st == E_ST_UINT16)then
			return 'uint16'
		elseif(type.st == E_ST_UINT32)then
			return 'uint32'
		elseif(type.st == E_ST_UINT64)then
			return 'uint64'
		end
	elseif(type.type == E_SNT_CONTAINER)then
		if(type.ct == E_CT_VECTOR)then
			return args.arg_list[1].ot
		elseif(type.ct == E_CT_STRING)then
			return 'char'
		end
	elseif(type.type == E_SNT_REFER)then
		return type.ot;
	end
end

function on_enum_name(enum)
	print_line(0, 'void write_' .. enum.name .. '_name(HPAbstractWriter *self, const ' .. enum.name .. ' data);')
end

function on_enum_number(enum)
	print_line(0, 'void write_' .. enum.name .. '_number(HPAbstractWriter *self, const ' .. enum.name .. ' data);')
end


function on_enum(enum)
	
	on_enum_name(enum)
	on_enum_number(enum)

	print_line(0, 'void write_' .. enum.name .. '(HPAbstractWriter *self, const ' .. enum.name .. ' data);')


	enum_list[enum.name] = true
end


function on_struct(object)
	t = 0;
	line = 'void write_' .. object.name .. '(HPAbstractWriter *self, const ' .. object.name .. ' *data'
	for key, value in pairs(object.parameters.par_list) do
		line = line .. ' , '
		line = line .. get_type(value.type, nil)
		line = line .. ' const ' .. get_symbol_access_by_type_prefix_reverse(value.identifier, value.type) .. value.identifier
	end
	line = line .. ');'
	print_line(t, line)
end


function on_union(object)
	t = 0;
	line = 'void write_' .. object.name .. '(HPAbstractWriter *self, const ' .. object.name .. ' *data'
	for key, value in pairs(object.parameters.par_list) do
		line = line .. ' , '
		line = line .. 'const ' .. get_type(value.type, nil)
		line = line .. ' ' .. get_symbol_access_by_type_prefix_reverse(value.identifier, value.type) .. value.identifier
	end
	line = line .. ');'
	print_line(t, line)
end

function main(hd)
	file_tag = hd.file_name
	file_tag = '_H_' .. string.gsub(hd.file_name, '[^a-zA-Z0-9]', '_') .. '_WRITER_HEADER'
	io.write('#ifndef ' .. file_tag .. '\n')
	io.write('#define ' .. file_tag .. '\n')
	print_line(0, '#include "hotpot/hp_platform.h"')
	print_line(0, '#include "hotprotocol/hp_abstract_writer.h"')

	if(c_types_file)then
		io.write('#include \"' .. c_types_file .. '\"\n')
	end
	for key, value in pairs(hd['definition_list']) do
		if(value.type == E_DT_ENUM)then
			on_enum(value.definition.de_enum)
		elseif(value.type == E_DT_STRUCT)then
			on_struct(value.definition.de_struct)
		elseif(value.type == E_DT_UNION)then
			on_union(value.definition.de_union)
		end
	end
	io.write('#endif//' .. file_tag .. '\n')
end

main(hd)

